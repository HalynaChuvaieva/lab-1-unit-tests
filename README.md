За основу для створення юніт тестів я взяла класи BinarySearchTree(дерево бінарного пошуку) та Graph(граф) написані у файлах BinarySearchTree.h та Graph.h відповідно. Всі юніт тести написала у файлі tests.cpp.

Для дерева бінарного пошуку я реалізувала юніт тести для методу insert, чи ігнорує цей метож повторювані числа, а також для minValue та delete, причому для delete я протестувала три випадки:

1. чи працює метод коректно(загальний)
2. дерево порожнє, (функція видалення має спокійно відпрацювати, а не спричинити падіння програми)
3. в дереві єдиний елемент

Для того щоб протестувати метод getHeight я створила додатковий клас TestBalancedBST на основі BalancedBST, оскільки BalancedBST абстрактний клас.
Написала п'ять юніт тестів для getHeight для різних випадків:

1. дерево порожнє
2. дерево містить один елемент
3. загальний випадок чи працює метод коректно
4. для право-збалансованого дерева
5. для ліво-збалансованого дерева

Для графів я реалізувала юніт тести для методів addEdge(додавання ребер в різних напрямках) buildSpanningTree (чи правильно будується кістякове дерево), bfs та окремий випадок bfs для ізольованої вершини.

Виправлені помилки:

1. У тесті BinarySearchTree minValue returns smallest node компілятор міг некоректно інтерпретувати Node всередині BSTTester, оскільки це було залежне ім'я типу в шаблонному класі, тому я використала ключове слово typename: using Node = typename BinarySearchTree::Node;
2. Для того щоб підвищити надійність тестів, я написала дві допоміжні функції: captureCout - для чистого захоплення виводу; parseOutputToVector - для парсингу захопленого рядка у вектор цілих чисел;
   Усі тести([BST][insert], [BST][delete], [BST][empty], [BST][duplicates], [BST][single], [Graph][addEdge], [Graph][spanningTree], [Graph][bfs], [Graph][bfs][isolated]), що використовували display(), тепер використовують парсинг.
