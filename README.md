За основу для створення юніт тестів я взяла класи BinarySearchTree(дерево бінарного пошуку) та Graph(граф) написані у файлах BinarySearchTree.h та Graph.h відповідно. Всі юніт тести написала у файлі tests.cpp.

Для дерева бінарного пошуку я реалізувала юніт тести для методу insert, чи ігнорує цей метож повторювані числа, а також для minValue та delete, причому для delete я протестувала три випадки:

1. чи працює метод коректно(загальний)
2. дерево порожнє, (функція видалення має спокійно відпрацювати, а не спричинити падіння програми)
3. в дереві єдиний елемент

Для того щоб протестувати метод getHeight я створила додатковий клас TestBalancedBST на основі BalancedBST, оскільки BalancedBST абстрактний клас.
Написала п'ять юніт тестів для getHeight для різних випадків:

1. дерево порожнє
2. дерево містить один елемент
3. загальний випадок чи працює метод коректно
4. для право-збалансованого дерева
5. для ліво-збалансованого дерева

Для графів я реалізувала юніт тести для методів addEdge(додавання ребер в різних напрямках) buildSpanningTree (чи правильно будується кістякове дерево), bfs та окремий випадок bfs для ізольованої вершини.

ВИПРАВЛЕНІ ПОМИЛКИ:

1. У тесті [BST][minValue] компілятор міг некоректно інтерпретувати Node всередині BSTTester, оскільки це було залежне ім'я типу в шаблонному класі, тому я використала ключове слово typename: using Node = typename BinarySearchTree::Node;
2. Для того щоб підвищити надійність тестів, я написала дві допоміжні функції: captureCout - для чистого захоплення виводу; parseOutputToVector - для парсингу захопленого рядка у вектор цілих чисел;
   Усі тести([BST][insert], [BST][delete], [BST][empty], [BST][duplicates], [BST][single], [Graph][addEdge], [Graph][spanningTree], [Graph][bfs], [Graph][bfs][isolated]), що використовували display(), тепер використовують парсинг.
3. Додала тест [BST][remove][non-existent], який перевіряє, що відбувається, коли ви намагаєтеся видалити елемент, якого немає у BST. Очікувана поведінка — дерево залишається незмінним і не кидає винятків (REQUIRE_NOTHROW).
4. У тесті [Graph][addEdge] додала сортування, щоб порівнювати сусідів, незалежно від порядку. Це потрібно для того, щоб тест не видавав помилок, якщо якщо порядок додавання сусідів у adj[1] зміниться (наприклад, якщо сусід 3 додасться раніше, ніж 2).
5. Змінила клас Graph, щоб функція обходу повертала структуровані дані (ребра), а не друкувала їх. Змінінила функцію buildSpanningTree так, щоб вона заповнювала вектор ребер замість друку. Тепер тест стає абсолютно надійним, оскільки порівнюються структури даних, а не текстовий вивід.
