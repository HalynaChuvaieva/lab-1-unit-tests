**Посилання на документацію: https://halynachuvaieva.github.io/lab-1-unit-tests/**
За основу для створення юніт тестів я взяла класи BinarySearchTree(дерево бінарного пошуку) та Graph(граф) написані у файлах BinarySearchTree.h та Graph.h відповідно. Всі юніт тести написала у файлі tests.cpp.

Для дерева бінарного пошуку я реалізувала юніт тести для методу insert, чи ігнорує цей метож повторювані числа, а також для minValue та delete, причому для delete я протестувала три випадки:

1. чи працює метод коректно(загальний)
2. дерево порожнє, (функція видалення має спокійно відпрацювати, а не спричинити падіння програми)
3. в дереві єдиний елемент

Для того щоб протестувати метод getHeight я створила додатковий клас TestBalancedBST на основі BalancedBST, оскільки BalancedBST абстрактний клас.
Написала п'ять юніт тестів для getHeight для різних випадків:

1. дерево порожнє
2. дерево містить один елемент
3. загальний випадок чи працює метод коректно
4. для право-збалансованого дерева
5. для ліво-збалансованого дерева

Для графів я реалізувала юніт тести для методів addEdge(додавання ребер в різних напрямках) buildSpanningTree (чи правильно будується кістякове дерево), bfs та окремий випадок bfs для ізольованої вершини.

# Виправлені помилки:

1. У тесті [BST][minValue] компілятор міг некоректно інтерпретувати Node всередині BSTTester, оскільки це було залежне ім'я типу в шаблонному класі, тому я використала ключове слово typename: using Node = typename BinarySearchTree::Node;
2. Для того щоб підвищити надійність тестів, я написала дві допоміжні функції: captureCout - для чистого захоплення виводу; parseOutputToVector - для парсингу захопленого рядка у вектор цілих чисел;
   Усі тести([BST][insert], [BST][delete], [BST][empty], [BST][duplicates], [BST][single], [Graph][addEdge], [Graph][spanningTree], [Graph][bfs], [Graph][bfs][isolated]), що використовували display(), тепер використовують парсинг.
3. Додала тест [BST][remove][non-existent], який перевіряє, що відбувається, коли ви намагаєтеся видалити елемент, якого немає у BST. Очікувана поведінка — дерево залишається незмінним і не кидає винятків (REQUIRE_NOTHROW).
4. У тесті [Graph][addEdge] додала сортування, щоб порівнювати сусідів, незалежно від порядку. Це потрібно для того, щоб тест не видавав помилок, якщо якщо порядок додавання сусідів у adj[1] зміниться (наприклад, якщо сусід 3 додасться раніше, ніж 2).
5. Змінила клас Graph, щоб функція обходу повертала структуровані дані (ребра), а не друкувала їх. Змінінила функцію buildSpanningTree так, щоб вона заповнювала вектор ребер замість друку. Тепер тест стає абсолютно надійним, оскільки порівнюються структури даних, а не текстовий вивід.

# Documentation
Налаштована автоматична генерація документації за допомогою **Doxygen** та її публікація через GitHub Pages. Усі класи та методи задокументовано у форматі Doxygen comments. Після створення конфігураційного файлу Doxyfile налаштувала наступні параметри: 
PROJECT_NAME           = "Data Structures Documentation"
OUTPUT_DIRECTORY       = docs
RECURSIVE              = YES
EXTRACT_ALL            = YES
GENERATE_HTML          = YES
GENERATE_LATEX         = NO
INPUT                  = .

**Локальна генерація документації**
Щоб перевірити, чи все працює, потрібно виконати команду: doxygen Doxyfile
Після цього документація з’явиться у папці: docs/html/index.html
Її можна відкрити у браузері.

**Налаштування CI/CD через GitHub Actions**
Було створено файл .github/workflows/docs.yml, який автоматично:
встановлює Doxygen та Graphviz;
генерує документацію;
публікує її на GitHub Pages.

**Публікація документації**
Після коміту та пушу змін у репозиторій GitHub Actions автоматично:
генерує документацію з коду;
публікує її на GitHub Pages.
